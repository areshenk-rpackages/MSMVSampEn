<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <meta name="viewport" content="width=device-width">

        <title>MSMVSampEn : Theory and computation</title>
        <meta name="description" content="Multiscale multivariate sample entropy in R">

        <link href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/css/bootstrap.min.css" rel="stylesheet">
        <link rel="stylesheet" href="/MSMVSampEn-site/css/syntax.css">
        <link rel="stylesheet" href="/MSMVSampEn-site/css/main.css">
    </head>
    <body>

        <div class="container">
            <div class="row">
                <div id="header" class="col-sm-12">
                    <h4><a class="brand" href="/MSMVSampEn-site/">MSMVSampEn</a>
    <small>Multiscale multivariate sample entropy in R</small>
</h4>

                </div>
            </div>

            <div class="row">
                
                
                    <div id="navigation" class="col-sm-2">
                        <ul class="nav nav-pills nav-stacked">
    <li><a href="/MSMVSampEn-site/">Home</a></li>
    
        
        

        
    
        
        

        
            
                <li class="nav-header">Documentation</li>
            
            <li data-order="1"><a href="/MSMVSampEn-site/doc/theory.html">Theory and computation</a></li>
        
    
        
        

        
    
<!-- List additional links. It is recommended to add a divider
    e.g. <li class="divider"></li> first to break up the content. -->
</ul>

                    </div>

                    <div id="content" class="col-sm-10">
                        <div class="page-header">
    <h2>Theory and computation
        
    </h2>
</div>

<p>Sample entropy, like its predecessor, approximate entropy, attempts to provide a computationally tractable quantification of the complexity of a time series. Loosely, it attempts to measure the “unpredictability” of a signal, defined as the degree to which future values of the signal can be predicted from past observations.</p>

<p>The general idea behind the approach is like this: We have a time series $\mathbf{X}$ (often a biological signal – say, scalp voltage), which we assume is the result of some underlying nonlinear dynamical system (brain activity). This system is high dimensional, but we only observe some unidimensional result of the system (the voltage at a single location). This is clearly not enough to reconstruct the system, but we can, in some sense, “extract” additional dimensions from $\mathbf{X}$ by looking at the change in $\mathbf{X}$ at different time lags, and then “projecting” the result into a higher dimension.</p>

<h2 id="sample-entropy-sampen">Sample entropy (SampEn)</h2>

<p>For example, the voltage \(x_t\) at a single time point is 1-dimensional, but we if we take \(m\) samples at lag \(\tau\), then we get the \(m\)-dimensional vector \(y^t_{\tau,m} = (x_t,x_{t+\tau},x_{t+2\tau},\dots,x_{t+m\tau})\). The value \(m\) is called the embedding dimension, and \(\tau\) the time lag. We can then ask the question: if two points are similar in embedding dimension \(m\) (that is, closer than some distance \(r\)), what is the probability that they will remain similar in dimension \(m+1\)? Letting \(A^m(x)\) be the probability that two points are similar in dimension \(m+1\), and \(B^m(x)\) be the probability that two points are similar in dimension $m$, SampEn estimates</p>

\[\text{SampEn}_{m,\tau,r} = -\ln{\frac{A^m(x)}{B^m(x)}}\]

<p>As an intuition aid, a constant or strictly periodic signal has zero entropy, whereas a signal with no correlation structure (such as white noise) has maximum entropy (what “maximum entropy” is, exactly, depends on the sample size and the parameters of the algorithm). SampEn thus provides a measure of the complexity of the signal.</p>

<h2 id="multiscale-entropy">Multiscale entropy</h2>

<p>Multiscale sample entropy (MSSampEn) is an extension of SampEn that examines the complexity of a time series at different time scales. The most common approach is straightforward: we partition \(\mathbf{X}\) into bins of length \(\epsilon\), and then compute the mean of \(\mathbf{X}\) within each bin, giving a new time series of length \(N/\epsilon\) (this procedure is called coarse-graining). SampEn can then be computed for various value of \(\epsilon\), estimating the complexity of \(\mathbf{X}\) at increasing time scales. Time series which are “locally” unpredictable, but which exhibit “low frequency” structure, might then be expected to show increasing entropy at longer time scales. Conversely, white noise is “scale invariant” in some sense, and so would show constant entropy at any time scale. This is easy to show by setting the similarity threshold \(r\) at some constant percentage of signal variance, which we can accomplish by scaling the series to have unit variance after coarse-graining. If the raw series is</p>

\[x_t \sim \mathrm{N}(0,1)\]

<p>the the coarse-grained series \(\mathbf{y}\) is</p>

\[y_t \sim \mathrm{N}\left (0,\frac{1}{\epsilon}\right)\]

<p>but after scaling, this is just more white noise, so SampEn is the same. If the series is not scaled after coarse-graining (or \(r\) is not adapted), then, because coarse-graining reduces signal variance, entropy will decrease monotonically as \(\epsilon\) increases.</p>

<p>Ahmed, M. U., &amp; Mandic, D. P. (2011). Multivariate multiscale entropy: A tool for complexity analysis of multichannel data. Physical Review E, 84(6), 061918.</p>



<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>
<script
  type="text/javascript"
  charset="utf-8"
  src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"
>
</script>
<script
  type="text/javascript"
  charset="utf-8"
  src="https://vincenttam.github.io/javascripts/MathJaxLocal.js"
>
</script>



                    </div>
                
            </div>

            

            <div class="row">
                <div id="footer" class="col-sm-12">
                    Documentation for <a href="https://github.com/areshenk/MSMVSampEn">MSMVSampEn</a>

                </div>
            </div>
        </div>

        <script>
            function orderNav() {
                var list,
                    section,
                    header,
                    sections = [],
                    lists = {},
                    headers = {};
                
                var locationObj = document.location.href;
                
                var navUl = document.querySelectorAll('#navigation ul')[0],
                    navLis = document.querySelectorAll('#navigation ul li');

                if (!navUl) return;

                for (var i = 0; i < navLis.length; i++) {
                    var order, li = navLis[i];

                    if (li.classList.contains('nav-header')) {
                        section = li.textContent || li.innerText;
                        sections.push(section);
                        headers[section] = li;
                        continue;
                    }

                    var link = li.childNodes[0];
                    if (locationObj && link && locationObj.endsWith(link.getAttribute('href'))) {
                        li.classList.add('active');
                    }
                    
                    if (!lists[section]) {
                        lists[section] = [];
                    }

                    order = parseFloat(li.getAttribute('data-order'))
                    lists[section].push([order, li]);
                }

                for (var i = 0; i < sections.length; i++) {
                    section = sections[i];
                    list = lists[section].sort(function(a, b) {
                        return a[0] - b[0];
                    });

                    if (header = headers[section]) {
                        navUl.appendChild(header);
                    }
                    for (var j = 0; j < list.length; j++) {
                        navUl.appendChild(list[j][1]);
                    }
                }
            }

            if (document.querySelectorAll) orderNav();
        </script>
        
    </body>
</html>
